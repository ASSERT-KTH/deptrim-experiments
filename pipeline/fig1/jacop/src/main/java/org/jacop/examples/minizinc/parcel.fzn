predicate jacop_alldistinct(array [int] of var int: x);
predicate jacop_among_var(array [int] of var int: x, array [int] of var int: v, var int: n);
predicate jacop_circuit(array [int] of var int: x);
predicate jacop_diff2(array [int] of var int: rects);
predicate jacop_knapsack(array [int] of int: w, array [int] of int: p, var int: W, var int: P, array [int] of var int: x);
predicate jacop_list_diff2(array [int] of var int: x, array [int] of var int: y, array [int] of var int: lx, array [int] of var int: ly);
predicate jacop_networkflow(array [int] of int: arc, array [int] of var int: flow, array [int] of var int: weight, array [int] of int: balance, var int: cost);
predicate jacop_stretch(array [int] of int: values, array [int] of int: min_v, array [int] of int: max_v, array [int] of var int: x);
var 11..20: INT____21 :: is_defined_var :: var_is_introduced;
var 21..30: INT____23 :: is_defined_var :: var_is_introduced;
var 31..40: INT____25 :: is_defined_var :: var_is_introduced;
var 41..50: INT____27 :: is_defined_var :: var_is_introduced;
var 51..60: INT____29 :: is_defined_var :: var_is_introduced;
var 61..70: INT____31 :: is_defined_var :: var_is_introduced;
var 71..80: INT____33 :: is_defined_var :: var_is_introduced;
var 81..90: INT____35 :: is_defined_var :: var_is_introduced;
var 91..100: INT____37 :: is_defined_var :: var_is_introduced;
var 0..10000: INT____39 :: is_defined_var :: var_is_introduced;
array [1..10] of var 1..10: cities :: output_array([1..10]);
array [1..10] of var 0..1000: costs;
var 8..1000: INT____38 :: var_is_introduced = costs[10];
var 8..1000: INT____36 :: var_is_introduced = costs[9];
var 8..1000: INT____34 :: var_is_introduced = costs[8];
var 8..1000: INT____32 :: var_is_introduced = costs[7];
var 8..1000: INT____30 :: var_is_introduced = costs[6];
var 8..1000: INT____28 :: var_is_introduced = costs[5];
var 8..1000: INT____26 :: var_is_introduced = costs[4];
var 8..1000: INT____24 :: var_is_introduced = costs[3];
var 8..1000: INT____22 :: var_is_introduced = costs[2];
var 8..1000: INT____20 :: var_is_introduced = costs[1];
array [1..100] of int: distance = [1000, 85, 110, 94, 71, 76, 25, 56, 94, 67, 85, 1000, 26, 70, 62, 60, 63, 62, 70, 49, 110, 26, 1000, 71, 87, 89, 88, 87, 93, 73, 94, 70, 71, 1000, 121, 19, 82, 106, 124, 105, 71, 62, 87, 121, 1000, 104, 53, 24, 8, 13, 76, 60, 89, 19, 104, 1000, 65, 89, 108, 93, 25, 63, 88, 82, 53, 65, 1000, 30, 57, 46, 56, 62, 87, 106, 24, 89, 30, 1000, 23, 20, 94, 70, 93, 124, 8, 108, 57, 23, 1000, 20, 67, 49, 73, 105, 13, 93, 46, 20, 20, 1000];
array [1..10] of int: load_parcel = [0, 1, 5, -6, 4, 3, -5, 2, 1, -3];
array [1..10] of var -6..5: loads;
var -6..5: INT____19 :: var_is_introduced = loads[10];
var -6..5: INT____18 :: var_is_introduced = loads[9];
var -6..5: INT____17 :: var_is_introduced = loads[8];
var -6..5: INT____16 :: var_is_introduced = loads[7];
var -6..5: INT____15 :: var_is_introduced = loads[6];
var -6..5: INT____14 :: var_is_introduced = loads[5];
var -6..5: INT____13 :: var_is_introduced = loads[4];
var -6..5: INT____12 :: var_is_introduced = loads[3];
var -6..5: INT____11 :: var_is_introduced = loads[2];
var -6..5: INT____10 :: var_is_introduced = loads[1];
array [1..10] of var 1..10: ordered_cities;
var 1..10: INT____9 :: var_is_introduced = ordered_cities[10];
var 1..10: INT____8 :: var_is_introduced = ordered_cities[9];
var 1..10: INT____7 :: var_is_introduced = ordered_cities[8];
var 1..10: INT____6 :: var_is_introduced = ordered_cities[7];
var 1..10: INT____5 :: var_is_introduced = ordered_cities[6];
var 1..10: INT____4 :: var_is_introduced = ordered_cities[5];
var 1..10: INT____3 :: var_is_introduced = ordered_cities[4];
var 1..10: INT____2 :: var_is_introduced = ordered_cities[3];
var 1..10: INT____1 :: var_is_introduced = ordered_cities[2];
var 0..10000: tour_length :: output_var = INT____39;
constraint array_int_element(INT____21, distance, INT____22);
constraint array_int_element(INT____23, distance, INT____24);
constraint array_int_element(INT____25, distance, INT____26);
constraint array_int_element(INT____27, distance, INT____28);
constraint array_int_element(INT____29, distance, INT____30);
constraint array_int_element(INT____31, distance, INT____32);
constraint array_int_element(INT____33, distance, INT____34);
constraint array_int_element(INT____35, distance, INT____36);
constraint array_int_element(INT____37, distance, INT____38);
constraint array_int_element(cities[1], distance, INT____20);
constraint array_int_element(ordered_cities[1], load_parcel, INT____10);
constraint array_int_element(ordered_cities[2], load_parcel, INT____11);
constraint array_int_element(ordered_cities[3], load_parcel, INT____12);
constraint array_int_element(ordered_cities[4], load_parcel, INT____13);
constraint array_int_element(ordered_cities[5], load_parcel, INT____14);
constraint array_int_element(ordered_cities[6], load_parcel, INT____15);
constraint array_int_element(ordered_cities[7], load_parcel, INT____16);
constraint array_int_element(ordered_cities[8], load_parcel, INT____17);
constraint array_int_element(ordered_cities[9], load_parcel, INT____18);
constraint array_int_element(ordered_cities[10], load_parcel, INT____19);
constraint array_var_int_element(ordered_cities[1], cities, INT____1);
constraint array_var_int_element(ordered_cities[2], cities, INT____2);
constraint array_var_int_element(ordered_cities[3], cities, INT____3);
constraint array_var_int_element(ordered_cities[4], cities, INT____4);
constraint array_var_int_element(ordered_cities[5], cities, INT____5);
constraint array_var_int_element(ordered_cities[6], cities, INT____6);
constraint array_var_int_element(ordered_cities[7], cities, INT____7);
constraint array_var_int_element(ordered_cities[8], cities, INT____8);
constraint array_var_int_element(ordered_cities[9], cities, INT____9);
constraint int_eq(ordered_cities[1], cities[1]);
constraint int_lin_eq([-1, 1], [INT____21, cities[2]], -10) :: defines_var(INT____21) :: domain;
constraint int_lin_eq([-1, 1], [INT____23, cities[3]], -20) :: defines_var(INT____23) :: domain;
constraint int_lin_eq([-1, 1], [INT____25, cities[4]], -30) :: defines_var(INT____25) :: domain;
constraint int_lin_eq([-1, 1], [INT____27, cities[5]], -40) :: defines_var(INT____27) :: domain;
constraint int_lin_eq([-1, 1], [INT____29, cities[6]], -50) :: defines_var(INT____29) :: domain;
constraint int_lin_eq([-1, 1], [INT____31, cities[7]], -60) :: defines_var(INT____31) :: domain;
constraint int_lin_eq([-1, 1], [INT____33, cities[8]], -70) :: defines_var(INT____33) :: domain;
constraint int_lin_eq([-1, 1], [INT____35, cities[9]], -80) :: defines_var(INT____35) :: domain;
constraint int_lin_eq([-1, 1], [INT____37, cities[10]], -90) :: defines_var(INT____37) :: domain;
constraint int_lin_eq([-1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [INT____39, costs[1], costs[2], costs[3], costs[4], costs[5], costs[6], costs[7], costs[8], costs[9], costs[10]], 0) :: defines_var(INT____39);
constraint int_lin_le([1, 1, 1, 1], [loads[1], loads[2], loads[3], loads[4]], 15);
constraint int_lin_le([1, 1, 1, 1, 1], [loads[1], loads[2], loads[3], loads[4], loads[5]], 15);
constraint int_lin_le([1, 1, 1, 1, 1, 1], [loads[1], loads[2], loads[3], loads[4], loads[5], loads[6]], 15);
constraint int_lin_le([1, 1, 1, 1, 1, 1, 1], [loads[1], loads[2], loads[3], loads[4], loads[5], loads[6], loads[7]], 15);
constraint int_lin_le([1, 1, 1, 1, 1, 1, 1, 1], [loads[1], loads[2], loads[3], loads[4], loads[5], loads[6], loads[7], loads[8]], 15);
constraint int_lin_le([1, 1, 1, 1, 1, 1, 1, 1, 1], [loads[1], loads[2], loads[3], loads[4], loads[5], loads[6], loads[7], loads[8], loads[9]], 15);
constraint int_lin_le([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [loads[1], loads[2], loads[3], loads[4], loads[5], loads[6], loads[7], loads[8], loads[9], loads[10]], 15);
constraint int_lin_lt([-1], [loads[1]], 0);
constraint int_lin_lt([-1, -1], [loads[1], loads[2]], 0);
constraint int_lin_lt([-1, -1, -1], [loads[1], loads[2], loads[3]], 0);
constraint int_lin_lt([-1, -1, -1, -1], [loads[1], loads[2], loads[3], loads[4]], 0);
constraint int_lin_lt([-1, -1, -1, -1, -1], [loads[1], loads[2], loads[3], loads[4], loads[5]], 0);
constraint int_lin_lt([-1, -1, -1, -1, -1, -1], [loads[1], loads[2], loads[3], loads[4], loads[5], loads[6]], 0);
constraint int_lin_lt([-1, -1, -1, -1, -1, -1, -1], [loads[1], loads[2], loads[3], loads[4], loads[5], loads[6], loads[7]], 0);
constraint int_lin_lt([-1, -1, -1, -1, -1, -1, -1, -1], [loads[1], loads[2], loads[3], loads[4], loads[5], loads[6], loads[7], loads[8]], 0);
constraint int_lin_lt([-1, -1, -1, -1, -1, -1, -1, -1, -1], [loads[1], loads[2], loads[3], loads[4], loads[5], loads[6], loads[7], loads[8], loads[9]], 0);
constraint int_lin_lt([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1], [loads[1], loads[2], loads[3], loads[4], loads[5], loads[6], loads[7], loads[8], loads[9], loads[10]], 0);
constraint jacop_circuit(cities);
solve :: int_search(cities, input_order, indomain_min, complete) minimize INT____39;
